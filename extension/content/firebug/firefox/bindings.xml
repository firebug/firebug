<?xml version="1.0"?>
<!-- See license.txt for terms of usage -->

<bindings xmlns="http://www.mozilla.org/xbl"
    xmlns:xbl="http://www.mozilla.org/xbl"
    xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
    xmlns:html="http://www.w3.org/1999/xhtml">

<binding id="initializer">
    <implementation>
        <destructor><![CDATA[
           Firebug.chrome.shutdown();
        ]]></destructor>
    </implementation>
</binding>

<binding id="panelBar">

    <!-- The XUL structure for the panel bar is specified in the XUL source
         inside each "panelBar" element.  This allows us to have panel bars
         with substantially different layous, including the ability to embed
         one panel bar within another - albeit at some cost in maintainability. -->
    <content>
        <children/>
    </content>

    <implementation>
        <constructor><![CDATA[
            this.tabBox = this.getChildElement("tabBox");
            this.deck = this.getChildElement("deck");
            this.browser = this.getChildElement("browser");
            this.panelTabs = this.getChildElement("panelTabs");
            this.tabMap = {};

            window.panelBarWaiter.panelBarReady();
        ]]></constructor>

        <method name="getChildElement">
            <parameter name="id"/>
            <body><![CDATA[
                // Construct a unique ID from the panel bar ID and the child element ID,
                // for example: "panelBar1-panelTabs".  This allows us to define children
                // in the XUL source, which in turn allows us to have panel bars with
                // substantially different layouts.
                return document.getElementById(this.id + "-" + id);
            ]]></body>
        </method>

        <method name="createTab">
            <parameter name="panelType"/>
            <body><![CDATA[
            var tab = document.createElement("panelTab");
            tab.panelType = panelType;

            var title = Firebug.getPanelTitle(panelType);
            var tooltip = Firebug.getPanelTooltip(panelType);
            tab.setAttribute("label", title);
            tab.setAttribute("tooltiptext", tooltip);

            this.tabMap[panelType.prototype.name] = tab;
            this.updateTab(panelType);

            return tab;
            ]]></body>
        </method>

        <method name="addTab">
            <parameter name="panelType"/>
            <body><![CDATA[
            var tab = this.createTab(panelType);
            this.panelTabs.appendChild(tab);
            ]]></body>
        </method>

        <method name="getTab">
            <parameter name="panelName"/>
            <body><![CDATA[
                return this.tabMap[panelName];
            ]]></body>
        </method>

        <method name="updateTab">
            <parameter name="panelType"/>
            <body><![CDATA[
            var tab = this.getTab(panelType.prototype.name);

            if (tab && panelType.prototype.activable)
            {
                var enabled = panelType.prototype.isEnabled();
                tab.setAttribute("aria-disabled", enabled ? "false" : "true");
            }

            // xxxHonza: Does this belong here?
            Firebug.StartButton.resetTooltip();
            ]]></body>
        </method>

        <method name="updatePanels">
            <parameter name="panelTypes"/>
            <body><![CDATA[
                this.tabMap = {};

                // Replace tabs at the same position if type has changed
                var i = 0;
                var tab = this.panelTabs.firstChild;
                for (; i < panelTypes.length && tab; tab = tab.nextSibling)
                {
                    var panelType = panelTypes[i++];
                    if (tab.panelType.prototype.name != panelType.prototype.name)
                    {
                        var newTab = this.createTab(panelType);
                        this.panelTabs.replaceChild(newTab, tab);
                        tab = newTab;
                    }
                    else
                        this.tabMap[panelType.prototype.name] = tab;
                }

                // Remove old tabs after the last panel
                while (tab)
                {
                    var nextTab = tab.nextSibling;
                    this.panelTabs.removeChild(tab);
                    tab = nextTab;
                }

                // Insert new tabs after the last old tab
                for (; i < panelTypes.length; ++i)
                {
                    var panelType = panelTypes[i];
                    var newTab = this.createTab(panelType);
                    this.panelTabs.appendChild(newTab);
                }

                // Make sure hidden panels are collapsed.
                if (Firebug.Options)
                    var prefValue = Firebug.Options.get("hiddenPanels");
                else
                    var prefValue = Firebug.getPref(Firebug.prefDomain, "hiddenPanels");
                if (!prefValue || !prefValue.length)
                    return;

                var closedPanels = prefValue.split(" ");
                for (i=0; i<closedPanels.length; i++)
                {
                    var tab = this.tabMap[closedPanels[i]];
                    if (tab)
                        FBL.collapse(tab, true);
                }
            ]]></body>
        </method>

        <method name="selectTab">
            <parameter name="tab"/>
            <body><![CDATA[
                var panelName = tab ? tab.panelType.prototype.name : null;
                this.selectPanel(panelName);
                var scrollBox = this.getElementsByClassName("panelbar-arrowscrollbox").item(0);
                scrollBox.ensureVisibleTab(tab);
            ]]></body>
        </method>

        <method name="selectPanel">
            <parameter name="panelName"/>
            <parameter name="forceUpdate"/>
            <parameter name="noRefresh"/>
            <body><![CDATA[
                var tab = panelName ? this.tabMap[panelName] : null;
                var panelType = tab ? tab.panelType : null;
                var panel = Firebug.currentContext ? Firebug.currentContext.getPanel(panelName) : null;

                if (panelName && !tab.panelType.prototype.parentPanel)
                {
                    if (Firebug.Options)
                        Firebug.Options.set("defaultPanelName", panelName);
                    else
                        Firebug.setPref(Firebug.prefDomain, "defaultPanelName", panelName);
                }

                // Make sure the panel is visible.
                this.togglePanel(panelName, true);

                if (panel && (panel == this.selectedPanel) && !forceUpdate)
                    return panel;

                if (FBTrace.DBG_PANELS)
                    FBTrace.sysout('selectPanel '+panelName+" panel: "+panel);

                this.hideSelectedPanel();

                //xxxHonza: can be removed, but Chromebug needs it for now.
                this.tabBox.removeAttribute("collapsed");

                if (this.selectedTab)
                    this.selectedTab.selected = false;

                this.selectedTab = tab;
                this.selectedPanel = panel;

                if (tab)
                {
                    tab.selected = true;
                    if (Firebug.A11yModel && Firebug.A11yModel.isEnabled() && Firebug.A11yModel.tabFocused &&!forceUpdate)
                        tab.focus();
                }

                if (panel)
                {
                    panel.panelBrowser = panel.browser ? panel.browser : this.browser;
                    panel.panelBrowser.currentPanel = panel;
                }

                if (!panel || panel.panelBrowser != this.browser)
                    this.browser.currentPanel = null;

                this.dispatch("selectingPanel");

                var sel = this.browser.contentWindow.getSelection();
                if (sel)
                    sel.removeAllRanges();

                this.showSelectedPanel(panelName);  // sets active attribute true

                if (panel && !noRefresh && panel.needsRefresh)
                {
                    delete panel.needsRefresh;
                    panel.refresh();
                }

                if (panel && panel.browser)
                {
                    if (panel.browser.parentNode != this.deck)
                        this.deck.appendChild(panel.browser);

                    this.deck.selectedPanel = panel.browser;
                }
                else
                    this.deck.selectedPanel = this.browser;

                this.dispatch("selectPanel");

                return panel;
            ]]></body>
        </method>

        <method name="dispatch">
            <parameter name="eventName"/>
            <body><![CDATA[
                var ev = document.createEvent("Events");
                ev.initEvent(eventName, true, false);
                this.dispatchEvent(ev);
            ]]></body>
        </method>

        <method name="showSelectedPanel">
            <parameter name="panelName"/>
            <body><![CDATA[
                var panel = this.selectedPanel;
                if (panel)
                {
                    panel.visible = true;
                    panel.panelNode.setAttribute("active", true);

                    var state = Firebug.getPanelState(panel);
                    panel.show(state);
                }
                else
                {
                    // Render default content (note that the template is available as soon as
                    // FB namespaces are evaluated)
                    if (Firebug.DisabledPanelBox)
                        Firebug.DisabledPanelBox.show(this.browser, panelName);
                }

                this.updateToolbarVisibility();
            ]]></body>
        </method>

        <method name="hideSelectedPanel">
            <body><![CDATA[
                var oldPanel = this.selectedPanel;
                if (oldPanel)
                {
                    var state = FBL.getPersistedState(Firebug.currentContext, oldPanel.name);
                    oldPanel.hide(state);

                    oldPanel.visible = false;  // xxxjjb Why three ways to un-show the panel?
                    oldPanel.panelNode.removeAttribute("active");
                }

                // Also hide disabled panel content if any.
                if (Firebug.DisabledPanelBox)
                    Firebug.DisabledPanelBox.hide(this.browser);
            ]]></body>
        </method>

        <method name="updateToolbarVisibility">
            <body><![CDATA[
                var noButtons = true;
                var toolbarInner = Firebug.chrome.$("fbToolbarInner");
                var box = toolbarInner.firstChild;
                while (box)
                {
                    var tagName = box.tagName.toLowerCase();
                    var collapsed = box.getAttribute("collapsed");
                    if (collapsed != "true")
                    {
                        if (tagName == "panelstatus" && !box.firstChild)
                        {
                            box = box.nextSibling;
                            continue;
                        }

                        noButtons = false;
                        break;
                    }

                    box = box.nextSibling;
                }

                var toolbar = Firebug.chrome.$("fbToolbox");
                FBL.collapse(toolbar, noButtons);
            ]]></body>
        </method>

        <method name="closePanel">
            <parameter name="panelName"/>
            <body><![CDATA[
                var tab = this.getTab(panelName);
                FBL.collapse(tab, true);
                this.storeHiddenPanels();

                if (this.selectedTab != tab)
                    return;

                // If the selected panel has been closed, select the first one that is visible.
                tab = this.panelTabs.firstChild;
                while (tab)
                {
                    if (FBL.isVisible(tab))
                    {
                        this.selectTab(tab);
                        break;
                    }
                    tab = tab.nextSibling;
                }
            ]]></body>
        </method>

        <method name="openPanel">
            <parameter name="panelName"/>
            <body><![CDATA[
                var tab = this.getTab(panelName);
                FBL.collapse(tab, false);
                this.storeHiddenPanels();
            ]]></body>
        </method>

        <method name="togglePanel">
            <parameter name="panelName"/>
            <parameter name="forceOpen"/>
            <body><![CDATA[
                var tab = this.getTab(panelName);
                if (!tab)
                    return;

                var open = FBL.isVisible(tab);
                if (open && forceOpen)
                    return;

                if (open)
                    this.closePanel(panelName);
                else
                    this.openPanel(panelName);
            ]]></body>
        </method>

        <method name="storeHiddenPanels">
            <body><![CDATA[
                var closedPanels = [];
                var tab = this.panelTabs.firstChild;
                while (tab)
                {
                    if (!FBL.isVisible(tab))
                        closedPanels.push(tab.panelType.prototype.name);
                    tab = tab.nextSibling;
                }
                if (Firebug.Options)
                    Firebug.Options.set("hiddenPanels", closedPanels.join(" "));
                else
                    Firebug.setPref(Firebug.prefDomain, "hiddenPanels", closedPanels.join(" "));
            ]]></body>
        </method>

        <method name="openAllPanels">
            <parameter name="event"/>
            <body><![CDATA[
                var tab = this.panelTabs.firstChild;
                while (tab)
                {
                    if (!FBL.isVisible(tab))
                        FBL.collapse(tab, false);
                    tab = tab.nextSibling;
                }
                if (Firebug.Options)
                    Firebug.Options.set("hiddenPanels", "");
                else
                    Firebug.setPref(Firebug.prefDomain, "hiddenPanels", "");
                FBL.cancelEvent(event);
            ]]></body>
        </method>
    </implementation>

    <handlers>
        <handler event="mousedown" button="0"><![CDATA[
            event.stopPropagation();
            var tab = event.target;
            for (; tab && !tab.panelType; tab = tab.parentNode);

            if (tab && tab.getAttribute("selected") != "true")
            {
                // Select after a timeout to increase teh snappy
                setTimeout(FBL.bindFixed(function()
                {
                    this.selectTab(tab);
                }, this));
            }
        ]]></handler>
    </handlers>
</binding>

<binding id="panelBarArrowscrollbox"
    extends="chrome://global/content/bindings/scrollbox.xml#arrowscrollbox-clicktoscroll">
    <implementation>
        <constructor><![CDATA[
            this.panelBar = FBL.getAncestorByClass(this, "panelBar");
            this.panelTabs = FBL.getElementByClass(this, "panelTabs");
            this.scrollbox = document.getAnonymousElementByAttribute(this, "anonid", "scrollbox");
            window.addEventListener("resize", this, false);
        ]]></constructor>
        <method name="_getScrollableElements">
            <body><![CDATA[
                return this.panelTabs.childNodes;
            ]]></body>
        </method>
        <method name="handleEvent">
            <parameter name="event"/>
            <body><![CDATA[
                switch (event.type) {
                case "resize":
                    this.adjustTabSize(event);
                break;
            }
            ]]></body>
        </method>
        <method name="adjustTabSize">
            <parameter name="event"/>
            <body><![CDATA[
            if (!this.initialized)
                return;

            // Don't shrink at all if the pref is set to zero or less.
            if (Firebug.panelTabMinWidth <= 0)
                return;

            var totalWidth = parseInt(this.scrollbox.boxObject.width, 10);
            if (!totalWidth)
                return;

            var tabs = FBL.cloneArray(this.panelTabs.children);
            if (!tabs.length)
                return;

            var availableSpace = totalWidth;
            while (tabs.length && availableSpace > 0)
            {
                var noSpace = true;
                var tabWidth = Math.max(Firebug.panelTabMinWidth, availableSpace / tabs.length);
                for (var i=0; i<tabs.length; i++)
                {
                    var tab = tabs[i];
                    tab.style.maxWidth = tab.selected == "true" ? "none" : tabWidth + "px";
                    if (tab.originalWidth <= tabWidth)
                    {
                        noSpace = false;
                        tabs.splice(i, 1);
                        availableSpace = availableSpace - tab.originalWidth;
                        break;
                    }
                }
                if (noSpace)
                    break;
            }
            ]]></body>
        </method>
        <method name="updateOriginalSize">
            <body><![CDATA[
            if (this.initialized)
                return;

            if (!this.panelTabs)
                return;

            var tab = this.panelTabs.firstChild;
            while (tab)
            {
                tab.originalWidth = tab.boxObject.width;
                tab = tab.nextSibling;
            }
            this.initialized = true;
            ]]></body>
        </method>
        <method name="ensureVisibleTab">
            <parameter name="tab"/>
            <body><![CDATA[
            if (tab)
                this.scrollBoxObject.ensureElementIsVisible(tab);
            ]]></body>
        </method>
    </implementation>
    <handlers>
        <handler event="underflow"><![CDATA[
            if (event.detail == 0)
                return; // Ignore vertical events
            this.updateOriginalSize();
        ]]></handler>
        <handler event="overflow"><![CDATA[
            if (event.detail == 0)
                return; // Ignore vertical events

            this.updateOriginalSize();

            this.ensureVisibleTab(this.panelBar.selectedTab);
        ]]></handler>
    </handlers>
</binding>

<binding id="panelBarTabList" display="xul:box">
    <content>
        <xul:toolbarbutton class="fb-tabs-alltabs-button noTabStop" type="menu" xbl:inherits="tooltiptext">
            <xul:menupopup anonid="popup" />
        </xul:toolbarbutton>
    </content>
    <implementation>
        <constructor>
        <![CDATA[
            this.popup = document.getAnonymousElementByAttribute(this, "anonid", "popup");
            this.panelBar = document.getElementById("fbPanelBar1");
        ]]>
        </constructor>
        <method name="updateMenuItems">
            <body><![CDATA[
            var visibleTabs = [];
            var menuItem = this.popup.firstChild;
            while (menuItem)
            {
                var checked = menuItem.getAttribute("checked") == "true";
                if (checked)
                    visibleTabs.push(menuItem);

                menuItem.removeAttribute("disabled");
                menuItem = menuItem.nextSibling;
            }

            // If there is only one panel visible don't allow to close it.
            if (visibleTabs.length == 1)
                visibleTabs[0].setAttribute("disabled", true);
            ]]></body>
        </method>
    </implementation>
    <handlers>
        <handler event="popupshowing"><![CDATA[
            var tab = this.panelBar.panelTabs.firstChild;
            while (tab)
            {
                var menuItem = document.createElement("menuitem");
                menuItem.setAttribute("class", "panelBarTabListMenuItem");
                menuItem.setAttribute("type", "checkbox");
                menuItem.setAttribute("checked", FBL.isVisible(tab));
                menuItem.setAttribute("label", tab.label);
                menuItem.panelType = tab.panelType;
                this.popup.appendChild(menuItem);
                tab = tab.nextSibling;
            }

            // Create separator
            this.popup.appendChild(document.createElement("menuseparator"));

            this.updateMenuItems();

            // The last menu item is for opening all panels.
            var menuItem = document.createElement("menuitem");
            menuItem.setAttribute("label", FBL.$STR("firebug.Show_All_Panels"));
            var listener = FBL.bind(this.panelBar.openAllPanels, this.panelBar);
            menuItem.addEventListener("command", listener, false);
            this.popup.appendChild(menuItem);

            return true;
        ]]></handler>
        <handler event="popuphidden"><![CDATA[
            FBL.eraseNode(this.popup);
        ]]></handler>
        <handler event="command"><![CDATA[
            var menuItem = event.originalTarget;
            var panelName = menuItem.panelType.prototype.name;
            this.panelBar.selectPanel(panelName);
        ]]></handler>
    </handlers>
</binding>

<binding id="panelBarTabListMenuItem" extends="chrome://global/content/bindings/menu.xml#menuitem-iconic">
    <implementation>
        <constructor>
        <![CDATA[
            var iconNode = document.getAnonymousElementByAttribute(this, "class", "menu-iconic-left");
            iconNode.allowEvents = true;
            iconNode.addEventListener("click", FBL.bind(this.onTogglePanel, this), true);
            iconNode.addEventListener("mouseover", FBL.bind(this.onOverToggleCheckmark, this, iconNode), true);
            this.panelBar = FBL.getAncestorByClass(this, "panelBar");
        ]]>
        </constructor>
        <method name="onTogglePanel">
            <parameter name="event"/>
            <body><![CDATA[
            if (this.getAttribute("disabled") == "true")
                return;

            var panelName = this.panelType.prototype.name;
            var checked = this.getAttribute("checked") == "true";
            this.setAttribute("checked", checked ? "false" : "true");
            this.panelBar.togglePanel(panelName, !checked);

            Firebug.chrome.$("panelBarTabList").updateMenuItems();
            ]]></body>
        </method>
        <method name="onOverToggleCheckmark">
            <parameter name="event"/>
            <parameter name="iconNode"/>
            <body><![CDATA[
            // xxxHonza: the goal here is to visually indicate that clicking on
            // checkmarks in the panel list popup selects the panel.
            // FBTrace.sysout('Here is the iconNode', iconNode);
            // iconNode.style.backgroundColor = "red";
            // So, iconNode here is XUL - change the current
            // background-image style (?) of <xul:image> to something that
            // pops out a little
            ]]></body>
        </method>
    </implementation>
</binding>

<binding id="panelTab" display="xul:button">
    <content>
        <xul:label class="panelTab-text" crop="right" flex="1"
                   xbl:inherits="value=label,accesskey,crop,toolbarmode,buttonstyle,disabled"/>
        <children includes="panelTabMenu"/>
    </content>
    <implementation>
        <constructor>
        <![CDATA[
            this.labelNode = document.getAnonymousElementByAttribute(this, "class", "panelTab-text"),
            this.setAttribute('role', 'tab');
            this.setAttribute('aria-haspopup', 'true');
            if (!this.tabMenu)
            {
                this.tabMenu = document.createElement("panelTabMenu");
                this.appendChild(this.tabMenu);
            }
            return this.tabMenu;
        ]]>
        </constructor>
        <property name="selected">
            <getter><![CDATA[
                return this.getAttribute("selected");
            ]]></getter>
            <setter><![CDATA[
                this.setAttribute("selected", val);
                this.tabMenu.updateVisibility();
            ]]></setter>
        </property>
        <property name="label">
            <getter><![CDATA[
                return this.labelNode.getAttribute("value");
            ]]></getter>
            <setter><![CDATA[
                this.labelNode.setAttribute(val);
            ]]></setter>
        </property>
    </implementation>
</binding>

<binding id="panelTabMenu" display="xul:button" extends="chrome://global/content/bindings/toolbarbutton.xml#toolbarbutton">
    <content>
        <!-- Specify an empty tooltiptext to avoid displaying tooltip from the tab -->
        <xul:menupopup anonid="popup" tooltiptext=""/>
        <xul:image anonid="menuTarget" class="menuTarget"/>
    </content>
    <implementation>
        <constructor>
        <![CDATA[
            this.setAttribute('role', 'presentation');
            this.popup = document.getAnonymousElementByAttribute(this, "anonid", "popup");
            this.panelBar = FBL.getAncestorByClass(this, "panelBar");
        ]]>
        </constructor>
        <field name="value"/>
        <method name="onEnable">
            <body><![CDATA[
            var panelType = this.panelBar.selectedTab.panelType;
            panelType.prototype.setEnabled(true);
            this.panelBar.updateTab(panelType);
            ]]></body>
        </method>
        <method name="onDisable">
            <body><![CDATA[
            var panelType = this.panelBar.selectedTab.panelType;
            panelType.prototype.setEnabled(false);
            this.panelBar.updateTab(panelType);
            ]]></body>
        </method>
        <method name="optionMenu">
            <parameter name="label"/>
            <parameter name="checked"/>
            <parameter name="command"/>
            <body><![CDATA[
            return {label: label, type: "radio", checked: checked,
                command: FBL.bindFixed(command, this)};
            ]]></body>
        </method>
        <method name="updateVisibility">
            <body><![CDATA[
            // Hide the mini-menu (displaying panel's option) if following is true:
            // 1) The panel isn't activable and so there are no enable/disable options.
            // 2) The panel doesn't provide any additional options.
            var panel = this.panelBar.selectedPanel;
            if (!panel)
                return;

            var panelItems = panel ? panel.getOptionsMenuItems(Firebug.currentContext) : null;
            if (!panel.activable && !(panelItems && panelItems.length))
                this.setAttribute("collapsed", "true");
            else
                this.removeAttribute("collapsed");
            ]]></body>
        </method>
        <method name="showMenu">
            <body><![CDATA[
            var popupBoxObject = this.popup.popupBoxObject;
            popupBoxObject.setConsumeRollupEvent(popupBoxObject.ROLLUP_NO_CONSUME);
            this.popup.showPopup(this, -1, -1, "popup", "bottomleft", "topleft");
            ]]></body>
        </method>
    </implementation>
    <handlers>
        <handler event="mousedown" button="0"><![CDATA[
            this.showMenu();
        ]]></handler>
        <handler event="popupshowing"><![CDATA[
            var tab = this.panelBar.selectedTab;
            if (!tab)
                return false;
            this.setAttribute('role', 'menu');
            var items = [];
            var panelType = tab.panelType;

            // Create menu items for activation (only for activable panels).
            if (tab.panelType.prototype.activable)
            {
                var enabled = tab.panelType.prototype.isEnabled();
                items.push(this.optionMenu("panel.Enabled", enabled, this.onEnable));
                items.push(this.optionMenu("panel.Disabled", !enabled, this.onDisable));
            }

            var panelItems = [];
            var panel = this.panelBar.selectedPanel;
            if (panel)
            {
                // Get panel's option items.
                var panelItems = panel.getOptionsMenuItems(Firebug.currentContext);
                if (panelItems && panelItems.length > 0)
                    items.push("-");
            }

            var menu = FBL.extendArray(items, panelItems);
            for (var i = 0; i < menu.length; ++i)
                FBL.createMenuItem(this.popup, menu[i]);

            if (!this.popup.childNodes.length)
                return false;

            return true;
        ]]></handler>
        <handler event="popuphidden"><![CDATA[
            this.setAttribute('role', 'presentation');
            FBL.eraseNode(this.popup);
        ]]></handler>
    </handlers>
</binding>

<binding id="panelStatus">
    <implementation>
        <method name="addItem">
            <parameter name="label"/>
            <parameter name="object"/>
            <parameter name="rep"/>
            <parameter name="separator"/>
            <body><![CDATA[
                if (this.firstChild)
                {
                    // extra box needed to fix alignment issue in Vista theme
                    var box = document.createElement("hbox");
                    box.setAttribute('role', 'separator');
                    box.setAttribute('align', 'center');
                    var sep = document.createElement("label");
                    sep.setAttribute("class", "panelStatusSeparator");
                    sep.setAttribute("value", separator);
                    sep.setAttribute('role', 'presentation');
                    box.appendChild(sep);
                    this.appendChild(box);
                }

                var item = document.createElement("toolbarbutton");
                item.setAttribute("class", "panelStatusLabel");
                item.setAttribute("label", label);
                item.repObject = object;
                item.rep = rep;
                this.appendChild(item);
                return item;
            ]]></body>
        </method>

        <method name="clear">
            <parameter name="tab"/>
            <body><![CDATA[
                while (this.lastChild)
                    this.removeChild(this.lastChild);
            ]]></body>
        </method>

        <method name="getItemByObject">
            <parameter name="object"/>
            <body><![CDATA[
                for (var item = this.lastChild; item; item = item.previousSibling)
                {
                    if (item.rep)
                    {
                        var itemObject = item.rep.getRealObject(item.repObject, Firebug.currentContext);
                        if (itemObject == object)
                            return item;
                    }
                }
            ]]></body>
        </method>

        <method name="selectObject">
            <parameter name="object"/>
            <body><![CDATA[
                var item = this.getItemByObject(object);
                this.selectItem(item);
            ]]></body>
        </method>

        <method name="selectItem">
            <parameter name="item"/>
            <body><![CDATA[
                if (this.selectedItem)
                    this.selectedItem.removeAttribute("selected");

                this.selectedItem = item;

                if (item)
                {
                    item.setAttribute("selected", "true");

                    var ev = document.createEvent("Events");
                    ev.initEvent("selectItem", true, false);
                    this.dispatchEvent(ev);
                }
            ]]></body>
        </method>
    </implementation>

    <handlers>
        <handler event="command" ><![CDATA[
            var object = Firebug.getRepObject(event.target);
            if (object)
            {
                var rep = Firebug.getRep(object, Firebug.currentContext);
                object = rep.getRealObject(object, Firebug.currentContext);
                if (object)
                {
                    this.selectObject(object);
                    Firebug.chrome.select(object, null, null, true);
                }
            }
        ]]></handler>

        <handler event="mouseover"><![CDATA[
            var object = Firebug.getRepObject(event.target);
            if (object)
            {
                var rep = Firebug.getRep(object, Firebug.currentContext);
                object = rep.getRealObject(object, Firebug.currentContext);
                if (object)
                    Firebug.Inspector.highlightObject(object, Firebug.currentContext);
            }
        ]]></handler>

        <handler event="mouseout"><![CDATA[
            Firebug.Inspector.highlightObject(null);
        ]]></handler>
    </handlers>
</binding>

<!-- This binding represents a location list used in a panel. The list is based
     on a menu-button (a toolbar button with popup menu) and its purposes it displaying
     available files on the current page. For instance, in the Script panel, the location
     list displays list of all scripts. -->
<binding id="panelFileList" display="xul:menu"
    extends="chrome://global/content/bindings/toolbarbutton.xml#menu-button">
    <content popup="_child">
        <xul:label class="toolbarbutton-text title" crop="right" flex="1"
            xbl:inherits="value=title"/>
        <xul:menupopup anonid="popup"/>
        <xul:toolbarbutton class="fb-toolbarbutton box-inherit toolbarbutton-menubutton-button"
            anonid="button" flex="1"
            xbl:inherits="disabled,crop,image,label,accesskey,command,align,dir,pack,orient" />
        <xul:dropmarker type="menu-button" class="toolbarbutton-menubutton-dropmarker"
            xbl:inherits="align,dir,pack,orient,disabled,label"/>
    </content>

    <resources>
        <stylesheet src="chrome://global/skin/toolbarbutton.css"/>
    </resources>

    <implementation>
        <constructor><![CDATA[
            this.popup = document.getAnonymousElementByAttribute(this, "anonid", "popup");
            this._closed = true;
        ]]></constructor>

        <property name="location">
            <getter><![CDATA[
                if (FBTrace.DBG_LOCATIONS)
                    FBTrace.sysout("location getter label:"+this.getAttribute('label')+" location: "+this.getAttribute('location'));
                return this.getAttribute("location");
            ]]></getter>

            <setter><![CDATA[
                var locator = this.getLocator();

                var fileName = null;
                if (!locator)
                {
                    fileName = "no locator!";
                }
                else if (val)
                {
                    var description = locator.getObjectDescription(val);
                    fileName = (description.label?description.label:description.name);
                }
                else
                    fileName = "(none)";

                this.repObject = val;
                this.setAttribute("label", FBL.cropString(fileName, 80));
                this.setAttribute("location", val);
                if (FBTrace.DBG_LOCATIONS)
                    FBTrace.sysout("location setter label:"+this.getAttribute('label')+" fileName: "+fileName+ " val: "+val);
            ]]></setter>
        </property>

        <method name="getLocator">
            <body><![CDATA[
                if (!this.locator)  // XXXjjb this is complicated because the location list depends upon the current panel
                {
                    var functionYieldingExpression = this.getAttribute("locationProvider");
                    try {
                    if (functionYieldingExpression && functionYieldingExpression.length > 0)
                        this.locator = eval(functionYieldingExpression);
                        } catch (e) { FBTrace.sysout("getLocator Fails "+e+" in "+window.location) ; }
                    if (!this.locator || typeof(this.locator) != 'function')
                    {
                        var whichBinding = this.getAttribute("id");
                        var msg = "ERROR: panelFileList "+whichBinding+" requires attribute \'locationProvider\', an expression yielding a function";
                        FBTrace.sysout(msg, {locator: this.locator, expression: functionYieldingExpression});
                        return null;
                    }
                }
                // The locator needs
                //     getObjectDescription(object): return {path, name}
                //     getLocationList(), a list of objects that can be fed into getObjectDescription
                //     getObjectLocation(object)
                return this.locator(this);
            ]]></body>
        </method>

        <method name="selectObject">
            <parameter name="object"/>
            <body><![CDATA[
                this.repObject = object;

                var ev = document.createEvent("Events");
                ev.initEvent("selectObject", true, false);
                this.dispatchEvent(ev);
            ]]></body>
        </method>

        <method name="enterActiveItem">
            <body><![CDATA[
                for (var child = this.popup.firstChild; child; child = child.nextSibling)
                {
                    if (child.getAttribute("_moz-menuactive") == "true")
                    {
                        this.location = child.repObject;
                        this.selectObject(child.repObject);
                        this.popup.hidePopup();
                    }
                }
            ]]></body>
        </method>

        <method name="onKeyPress">
            <parameter name="event"/>
            <body><![CDATA[
                if (event.keyCode == 13) // Return
                {
                    this.enterActiveItem();
                    FBL.cancelEvent(event);
                }

                this.filter.onKeyPress(event);
            ]]></body>
        </method>

        <method name="onClick">
            <parameter name="event"/>
            <body><![CDATA[
                //https://developer.mozilla.org/en/XUL/arrowscrollbox
                var scrollbutton = event.originalTarget;
                var anonid = scrollbutton.getAttribute("anonid");
                if (anonid == 'scrollbutton-up')
                    scrollbutton.parentNode.scrollByIndex(-15);
                if (anonid == 'scrollbutton-down')
                    scrollbutton.parentNode.scrollByIndex(+15);
            ]]>
            </body>
        </method>

    </implementation>

    <handlers>
        <handler event="popupshowing"><![CDATA[
            if (this.popup.firstChild)
                return false;

            var locator = this.getLocator();
            var objects = locator.getLocationList();
            if (!objects)
            {
                this.setAttribute("label", "");
                this.setAttribute("location", null);
                return false;
            }

            if (locator.getLocationContent)
            {
                locator.getLocationContent(objects, this.popup);
                return;
            }

            this.filter = FBL.createMenuHeader(this.popup,
                {label: "script.Type any key to filter list"});
            FBL.setClass(this.filter, "fbURLMenuItem");
            FBL.setClass(this.filter, "fbLocationListFilter");

            var groupNames = [];
            var groups = {};

            var currentDescription = null;
            if (this.repObject)
                currentDescription = locator.getObjectDescription(this.repObject);

            for (var i = 0; i < objects.length; ++i)
            {
                var object = objects[i];
                var description = locator.getObjectDescription(object);
                if (!description)
                    FBTrace.sysout("binding.xml popupshowing Fails" , object);

                var entry = {object: object, fileName: description.name};

                if (currentDescription && currentDescription.name == description.name &&
                    currentDescription.path == description.path)
                {
                    entry.selected = true;
                }

                if (groups.hasOwnProperty(description.path))
                {
                    groups[description.path].push(entry);
                }
                else
                {
                    groups[description.path] = [entry];
                    groupNames.push(description.path);
                }
            }

            groupNames.sort();

            for (var i = 0; i < groupNames.length; ++i)
            {
                var path = groupNames[i];
                var urls = groups[path];
                urls.sort(function(a, b) { return a.fileName < b.fileName ? -1 : 1; });

                var menuHeader = FBL.createMenuHeader(this.popup, {label: path, nol10n: true});
                FBL.setClass(menuHeader, "fbURLMenuItem");

                for (var j = 0; j < urls.length; ++j)
                {
                    var menuInfo = {label: urls[j].fileName, nol10n: true};

                    if (urls[j].selected)
                    {
                        menuInfo.type = "checkbox";
                        menuInfo.checked = true;
                    }

                    var menuItem = FBL.createMenuItem(this.popup, menuInfo);
                    menuItem.repObject = urls[j].object;
                    FBL.setClass(menuItem, "fbURLMenuItem");
                }
            }
        ]]></handler>

        <handler event="popupshown"><![CDATA[
            // Weird, but this gets fired when the user clicks on a menuitem,
            // which hiding the buttons again and resulting in jitters - let's avoid that.
            if (!this._closed)
                return;

            this._closed = false;

            this.filter.filterString = "";

            this.onkeypress = FBL.bind(this.onKeyPress, this);
            window.top.addEventListener("keypress", this.onkeypress, true);

            this.onclick = FBL.bind(this.onClick, this);
            this.popup.addEventListener("click", this.onclick, true);
        ]]></handler>

        <handler event="popuphidden"><![CDATA[
            window.top.removeEventListener("keypress", this.onkeypress, true);
            delete this.onkeypress;

            delete this.filter.filterString;

            FBL.eraseNode(this.popup);
            this._closed = true;
        ]]></handler>

        <handler event="command"><![CDATA[
            var object = event.originalTarget.repObject;

            // Select after a timeout to increase teh snappy
            setTimeout(FBL.bindFixed(function()
            {
                this.selectObject(object);
            }, this));
        ]]></handler>

        <handler event="mouseover"><![CDATA[
            var object = Firebug.getRepObject(event.target);
            if (object)
            {
                var locator = this.getLocator();
                if (locator.getObjectLocation)
                    event.target.setAttribute('tooltiptext', locator.getObjectLocation(object));
                else
                {
                    if (FBTrace.DBG_LOCATIONS)
                        FBTrace.sysout("!locator.getObjectLocation for "+ this.getAttribute('label'), locator);
                }
            }
            return;
        ]]></handler>
    </handlers>
</binding>

<!-- Panel file list filter is used in the file list (location list) to filter its content. -->
<binding id="panelFileListFilter">
    <implementation>
        <constructor><![CDATA[
           this.popup = this.parentNode;
        ]]></constructor>

        <method name="filterList">
            <parameter name="substring"/>
            <body><![CDATA[
                this.firstMatch = null;
                var groupMatchCount = 0;
                substring = substring.toLowerCase();
                for (var child = this.popup.lastChild; child; child = child.previousSibling)
                {
                    if (child.localName == "menuitem")
                    {
                        var label = child.getAttribute("label").toLowerCase();
                        child._searchMatch = label.indexOf(substring) != -1;
                        if (child._searchMatch)
                        {
                            this.firstMatch = child;
                            ++groupMatchCount;
                        }
                    }
                    else
                    {
                        child._searchMatch = !!groupMatchCount;
                        groupMatchCount = 0;
                    }
                }

                if (this.firstMatch)
                {
                    // skip the filterMessageHeader
                    for (var child = this.popup.firstChild.nextSibling; child; child = child.nextSibling)
                        child.hidden = !child._searchMatch;

                    try
                    {
                        var toolbarButton = this.popup.parentNode;
                        if(toolbarButton.boxObject instanceof Components.interfaces.nsIMenuBoxObject)
                            toolbarButton.boxObject.activeChild = this.firstMatch;
                    }
                    catch (err)
                    {
                        if (FBTrace.DBG_ERRORS)
                            FBTrace.sysout("bindings; panelFileListFilter EXCEPTION " + err, err);
                    }
                }

                return this.firstMatch;
            ]]></body>
        </method>

        <method name="onKeyPress">
            <parameter name="event"/>
            <body><![CDATA[
                if (event.keyCode == 13) // Return
                {
                    this.filterString = "";
                }
                else if (event.keyCode == 8) // Backspace
                {
                    this.filterString = this.filterString.substr(0, this.filterString.length-1);
                    this.filterList(this.filterString);
                }
                else if (event.charCode)
                {
                    this.filterString += String.fromCharCode(event.charCode).toLowerCase();
                    this.filterList(this.filterString);
                }
                else
                {
                    return;
                }

                this.setFilterStringMessage(this.filterString, this.firstMatch);
                FBL.cancelEvent(event);
            ]]></body>
        </method>

        <method name="setFilterStringMessage">
            <parameter name="filterString"/>
            <parameter name="matched"/>
            <body><![CDATA[
                // The placeholder is displayed in gray while the filter is in black.
                this.setAttribute("keyword", filterString ? true : false);

                // If there is no match the background is red.
                this.setAttribute("match", matched ? true : false);

                // Set the text into the box. If the user entirely removed the text use
                // the placeholder again.
                filterString = filterString ? filterString :
                    FBL.$STR("script.Type any key to filter list");

                this.setAttribute("value", filterString);
            ]]>
            </body>
        </method>
    </implementation>
</binding>

<!-- Searchbox is located in the main Firebug toolbar and can be used to search
    for a keyword within the current panel. -->
<binding id="searchBox">
    <content sizetopopup="none">
        <xul:textbox anonid="searchBox"
            rows="1" label="search.Firebug_Search" class="fbsearch-textbox"
            onkeyup="onSearchBoxKeyUp(event);" aria-describedby="fbSearchBoxDescription" />
        <xul:description anonid="fbSearchBoxDescription"  collapsed="true"/>
        <xul:panel id="fbSearchOptionsPanel" norestorefocus="true" noautofocus="true"
            ignorekeys="true" role="presentation">
            <xul:description id="fbSearchBoxIsSensitive" value="search.Case AutoSensitive"/>
            <xul:description id="fbSearchBoxIsNotSensitive" value="search.Case Insensitive"/>
            <xul:vbox class="searchOptionsMenu innerToolbar" role="menu" anonid="fbSearchOptionsMenu">
              <xul:box anonid="startPanelFocus" class="panelFocusBound" onfocus="startFocusHandler()" />
              <xul:vbox anonid="searchOptionsList" role="presentation" />
              <xul:hbox pack="center" align="center" role="presentation">
                  <xul:button anonid="searchPrev" class="fbsearch-options-buttons a11yFocus"
                    label="search.Previous" oncommand="searchPrev()" role="menuitem" />
                  <xul:button anonid="searchNext" class="fbsearch-options-buttons a11yFocus"
                    label="search.Next" oncommand="searchNext()" role="menuitem" />
              </xul:hbox>
              <xul:box anonid="endPanelFocus" class="panelFocusBound" onfocus="endFocusHandler()" />
            </xul:vbox>
        </xul:panel>
        <xul:box anonid="endTextFocus" class="panelFocusBound" onfocus="endTextFocusHandler()" />
    </content>

    <implementation>
        <constructor><![CDATA[
            var searchBox = document.getAnonymousElementByAttribute(this, "anonid", "searchBox"),
                searchPrev = document.getAnonymousElementByAttribute(this, "anonid", "searchPrev"),
                searchNext = document.getAnonymousElementByAttribute(this, "anonid", "searchNext"),
                searchMenu = document.getAnonymousElementByAttribute(this, "anonid", "fbSearchOptionsMenu"),
                searchDescription = document.getAnonymousElementByAttribute(this, "anonid", "fbSearchBoxDescription"),
                optionsPopup = document.getElementById("fbSearchOptionsPanel");
                if (searchMenu)
                    searchMenu.setAttribute("aria-label", FBL.$STR("a11y.labels.search options"))
                if (searchDescription)
                    searchDescription.setAttribute("tooltiptext", FBL.$STR("a11y.labels.Press up or down arrow key for search options"))
            FBL.internationalize(searchBox, "label");
            FBL.internationalize(searchPrev, "label");
            FBL.internationalize(searchNext, "label");

            searchBox.addEventListener("focus", FBL.bind(this.focusHandler, this), true);
            optionsPopup.addEventListener("focus", FBL.bind(this.panelFocusHandler, this), true);
        ]]></constructor>
        <property name="value">
            <xbl:getter><![CDATA[
                var searchBox = document.getAnonymousElementByAttribute(this, "anonid", "searchBox");
                return searchBox.value;
            ]]></xbl:getter>
            <xbl:setter><![CDATA[
                var searchBox = document.getAnonymousElementByAttribute(this, "anonid", "searchBox");
                searchBox.value = val;
            ]]></xbl:setter>
        </property>
        <property name="placeholder">
            <xbl:getter><![CDATA[
                var searchBox = document.getAnonymousElementByAttribute(this, "anonid", "searchBox");
                return searchBox.placeholder || searchBox.emptytext;
            ]]></xbl:getter>
            <xbl:setter><![CDATA[
                var searchBox = document.getAnonymousElementByAttribute(this, "anonid", "searchBox");
                searchBox.placeholder = searchBox.emptytext = val;
            ]]></xbl:setter>
        </property>
        <property name="status">
            <xbl:getter><![CDATA[
                return searchBox.getAttribute("status");
            ]]></xbl:getter>
            <xbl:setter><![CDATA[
                var searchBox = document.getAnonymousElementByAttribute(this, "anonid", "searchBox");
                searchBox.setAttribute("status", searchBox.value == "" || val);
                searchBox.placeholder = searchBox.emptytext = "";
            ]]></xbl:setter>
        </property>
        <property name="optionsShown">
            <xbl:getter><![CDATA[
                var optionsPopup = document.getElementById("fbSearchOptionsPanel");
                return optionsPopup.state == "open";
            ]]></xbl:getter>
        </property>

        <!-- Flag indicating that the child of the panel has or just had focus -->
        <field name="panelHasFocus" />
        <field name="blurTimeout" />

        <method name="updateOptions">
            <parameter name="menuItems" />
            <body><![CDATA[
                var searchOptions = document.getAnonymousElementByAttribute(this, "anonid", "searchOptionsList");
                FBL.eraseNode(searchOptions);

                if (menuItems)
                {
                    for (var i=0; i<menuItems.length; i++)
                    {
                        var checkbox = document.createElement("checkbox");
                        checkbox.className = "fbsearch-options-label a11yFocus";
                        checkbox.setAttribute("role", "menuitemcheckbox")
                        FBL.setItemIntoElement(checkbox, menuItems[i]);

                        searchOptions.appendChild(checkbox);
                    }
                }
            ]]></body>
        </method>
        <method name="showOptions">
            <body><![CDATA[
                var optionsPopup = document.getElementById("fbSearchOptionsPanel"),
                    searchBox = document.getAnonymousElementByAttribute(this, "anonid", "searchBox"),
                    position = (Firebug.getPlacement() == "detached") ? "after_end" : "before_end";
                optionsPopup.setAttribute("position", position);
                optionsPopup.openPopup(this, position, 0, 0, false, false);

                clearTimeout(this.blurTimeout);
                delete this.blurTimeout;
            ]]></body>
        </method>
        <method name="hideOptions">
            <body><![CDATA[
                var optionsPopup = document.getElementById("fbSearchOptionsPanel");
                optionsPopup.hidePopup();

                clearTimeout(this.blurTimeout);
                delete this.blurTimeout;
            ]]></body>
        </method>
        <method name="searchNext">
            <body><![CDATA[
                this.status = (Firebug.Search.searchNext(Firebug.currentContext) ? "found" : "notfound");
            ]]></body>
        </method>
        <method name="searchPrev">
            <body><![CDATA[
                this.status = (Firebug.Search.searchPrev(Firebug.currentContext) ? "found" : "notfound");
            ]]></body>
        </method>

        <method name="focus">
            <body><![CDATA[
                var searchBox = document.getAnonymousElementByAttribute(this, "anonid", "searchBox");
                searchBox.focus();
            ]]></body>
        </method>
        <method name="select">
            <body><![CDATA[
                var searchBox = document.getAnonymousElementByAttribute(this, "anonid", "searchBox");
                searchBox.select();
            ]]></body>
        </method>

        <!-- Focus management handlers. These must be defined as methods and registered
            using addEventListener or attribute registration as XBL handlers do not
            appear to allow access to anonymous event targets when capturing. -->
        <method name="focusHandler">
            <parameter name="event" />
            <body><![CDATA[
                var target = event.target;
                clearTimeout(this.blurTimeout);
                delete this.blurTimeout;

                if (!FBL.hasClass(target, "panelFocusBound")) {
                    this.showOptions();
                }
            ]]></body>
        </method>
        <method name="panelFocusHandler">
            <parameter name="event" />
            <body><![CDATA[
                this.focusHandler(event);

                if (!FBL.hasClass(event.target, "panelFocusBound")) {
                    this.panelHasFocus = true;
                }
            ]]></body>
        </method>
        <method name="endTextFocusHandler">
            <body><![CDATA[
                clearTimeout(this.blurTimeout);
                delete this.blurTimeout;

                if (this.panelHasFocus) {
                    // The user has just tabbed out of the panel
                    document.commandDispatcher.advanceFocus();
                    this.panelHasFocus = false;
                } else if (this.optionsShown) {
                    // The user has just tabbed out of the search box (and into the panel)
                    var optionsPopup = document.getElementById("fbSearchOptionsPanel");
                    document.commandDispatcher.advanceFocusIntoSubtree(optionsPopup);
                } else {
                    // The user has just reverse tabbed from the next tab target
                    this.showOptions();

                    var searchNext = document.getAnonymousElementByAttribute(this, "anonid", "searchNext");
                    setTimeout(function() { searchNext.focus(); }, 0);
                    this.panelHasFocus = true;
                }
            ]]></body>
        </method>
        <method name="startFocusHandler">
            <body><![CDATA[
                if (this.panelHasFocus) {
                    // The user has shift-tabbed out of the panel
                    var searchBox = document.getAnonymousElementByAttribute(this, "anonid", "searchBox")
                    searchBox.focus();
                } else {
                    // The user has just tabbed into the panel
                    document.commandDispatcher.advanceFocus();
                    this.panelHasFocus = true;
                }
            ]]></body>
        </method>
        <method name="endFocusHandler">
            <body><![CDATA[
                // The user has just tabbed out of the panel
                this.hideOptions();

                var endTextFocus = document.getAnonymousElementByAttribute(this, "anonid", "endTextFocus");
                endTextFocus.focus();
            ]]></body>
        </method>
        <method name="onSearchBoxKeyUp">
            <parameter name="event" />
            <body><![CDATA[
                if (!Firebug.A11yModel || !Firebug.A11yModel.isEnabled())
                    return;
                if (event.keyCode ==  KeyEvent.DOM_VK_UP || event.keyCode ==  KeyEvent.DOM_VK_DOWN)
                {
                    var goingDown = event.keyCode ==  KeyEvent.DOM_VK_DOWN;
                    var optionsPopup = document.getElementById("fbSearchOptionsPanel");
                    var items = optionsPopup.getElementsByClassName("a11yFocus");
                    if (!optionsPopup || !items)
                        return;
                    if (optionsPopup.state == "closed")
                        this.showOptions();
                    setTimeout(FBL.bindFixed(function(){items[goingDown ? 0 : items.length -1].focus();}));
                }
                else if (event.keyCode ==  KeyEvent.DOM_VK_ESCAPE)
                    this.hideOptions();
            ]]></body>
        </method>
    </implementation>
    <handlers>
        <handler event="keypress"><![CDATA[
            if (event.keyCode ==  KeyEvent.DOM_VK_ESCAPE)
            {
                var optionsPopup = document.getElementById("fbSearchOptionsPanel");
                var searchBox = document.getAnonymousElementByAttribute(this, "anonid", "searchBox");
                if (!optionsPopup || !searchBox)
                    return;
                searchBox.focus();
                if (optionsPopup.state == "open")
                {
                    event.stopPropagation(); // prevent cmd popup toggle
                    optionsPopup.hidePopup();
                }
                else
                    return;
            }
            else if (event.keyCode ==  KeyEvent.DOM_VK_RETURN)
            {
                if (FBL.isShift(event))
                    this.searchPrev();
                else if (FBL.isControl(event))
                    FBL.dispatch([Firebug.A11yModel], 'moveToSearchMatch');
                else
                    this.searchNext();
            }
            else
                return;

            FBL.cancelEvent(event);
        ]]></handler>

        <handler event="input"><![CDATA[
            Firebug.Search.update(Firebug.currentContext);
        ]]></handler>

        <handler event="popupshowing"><![CDATA[
            this.panelHasFocus = false;
        ]]></handler>
        <handler event="blur" phase="capturing"><![CDATA[
            this.blurTimeout = this.blurTimeout || setTimeout(function() {
                hideOptions();
            }, 0);
        ]]></handler>
    </handlers>
</binding>



<binding id="largeCommandLine" extends="chrome://global/content/bindings/textbox.xml#textarea">
    <handlers>
        <handler event="input"><![CDATA[
            Firebug.CommandLine.update(Firebug.currentContext);
        ]]></handler>

        <handler event="keypress" keycode="VK_TAB"><![CDATA[
            var input = document.getAnonymousElementByAttribute(this, "anonid", "input");
            FBL.insertTextIntoElement(input, Firebug.Editor.tabCharacter);
            event.preventDefault();
        ]]></handler>

        <handler event="keypress" keycode="VK_RETURN" modifiers="meta" preventdefault="true"><![CDATA[
            Firebug.CommandLine.enter(Firebug.currentContext);
        ]]></handler>

        <handler event="keypress" keycode="VK_RETURN" modifiers="control" preventdefault="true"><![CDATA[
            Firebug.CommandLine.enter(Firebug.currentContext);
        ]]></handler>

        <handler event="keypress" keycode="VK_ESCAPE" preventdefault="true"><![CDATA[
            Firebug.CommandLine.cancel(Firebug.currentContext);
        ]]></handler>
    </handlers>
</binding>


<binding id="splitmenu" extends="chrome://global/content/bindings/menu.xml#menuitem-base">
    <content align='stretch'>
        <xul:menuitem anonid="item" flex="1"
                    class="menuitem-tooltip split-menuitem-item"
                    xbl:inherits="label,key,image,value" allowevents='true'/>
        <xul:hbox class="split-menu-right-image" xbl:inherits="_moz-menuactive" >
            <xul:hbox align="center" class="menu-right" xbl:inherits="_moz-menuactive,disabled">
                <xul:image/>
            </xul:hbox>
        </xul:hbox>
        <children includes="menupopup"/>
    </content>

    <implementation implements="nsIDOMXULSelectControlItemElement, nsIDOMXULContainerItemElement, nsIAccessibleProvider">
        <constructor><![CDATA[
            if (this.getAttribute("iconic") == "true") {
                this.item.classList.remove("menuitem-tooltip");
                this.item.classList.add("menuitem-iconic-tooltip");
                this.item.classList.add("menuitem-iconic");
            }
            // workaround for 3.6 bug
            this.item.classList.add("split-menuitem-item");
      ]]></constructor>
      <field name="item" readonly="true">
            document.getAnonymousElementByAttribute(this, "anonid", "item");
      </field>
    </implementation>
</binding>

</bindings>
